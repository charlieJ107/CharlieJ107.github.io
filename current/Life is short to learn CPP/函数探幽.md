# 函数探幽

## 内联函数

1. 作用:提高运行速度(空间换时间)

2. 原理:

   1. 不用内联: 调用函数->挂起->前往执行函数代码->赋值->继续
   2. 用内联: 直接编译复制一份函数代码, 丢进去执行, 直接继续

3. 常用于被经常调用且不是很占内存的函数

4. 限制: 不能递归

5. 用法: 

   * 在函数声明前加上关键字`inline`
   * 在函数定义前加上关键字`inline`

6. 示例

   ```c++
   #include <iostream>
   
   //an inline function definition
   inline double square(double x)
   {
       retrun x*x;
   }
   
   int main()
   {
       using namespace std;
       double a,b;
       double c = 13.0;
       a=square(5.0);
       b=square(4.5+7.5);//can pass expressions
       
       //output
       
       return 0;
   }
   ```





## 引用变量

1. 已经定义的变量的一个别名

2. 作用: 作为函数的形参, 这样就可以直接使用那个参数的原始数据, 而非复制一份到函数里面执行. 这对当参数背后的数据非常大的时候可以节省内存的开销. 比如大型的结构体或者对象.

3.  创建方法: `&`运算符

   ```c++
   int rate;
   int & rodents =rate;
   ```

   其中,  `int & `表示指向`int` 的引用.

   

   

4. 与指针区分: 

   ```c++
   int rats = 101;
   int & rodents = rats;//refernce
   int * prats = &rats;//pointer
   ```

   `rodents` 和 `*prats`都可以和`rats`互换,  `&rodents`和`prats`可以和`&rats`互换. 从表面上看引用有点像伪装表示的指针, 即`*`被省略. 但他们的差别主要在:

   1. 必须在声明引用的时候将其初始化, 指针可以先声明, 需要的时候再赋值

   2. 引用更接近const指针, 必须在创建的时候就将其初始化. 

   3. 考虑下面这个情况:

      ```c++
      int rats = 101;
      int & rodents = rats;//rodents is a reference
      
      int bunnies = 50;
      rodents = bunnies;
      //这句等效于:
      rats = bunnies;
      ```

      说明引用一旦被声明, 始终会跟着初始化的时候的变量走, 不会因为赋值操作从A变量的引用变成B变量的引用. 

5. 使用方法

   ```c++
   void grumpy(int &x);
   int main()
   {
       int times = 20;
       grumpy(times);
   }
   void grumpy(int &x)
   {
       ...
   }
   ```

   

6. 需要注意的地方:

   例:

   ```c++
   int wallet1 = 300;
   int wallet2 = 350;
   //1. Use references
   void swapr(int & a, int & b)
   {
       int temp;
       temp = a;
       a = b;
       b = temp;
   }
   swapr(wallet1, wallet2);//pass variables
   ```
   
   此时交换出来wallet1是350, wallet2是300. 可以看出是成功交换了数据. 这个过程是在函数内部直接使用传进去两个变量的引用, 就地使用和修改变量的值, 除了不会另外开辟内存来创建变量以外, 没有其他区别.
   
```c++
   //2. use pointer
   void swapP(int * p, int * q)
   {
       int temp;
       
       temp = *p;
       *p = *q;
       *q = temp;
   }
   swapr(&wallet1, &wallet2);
```

   这是用指针交换, 指针进去的是地址, 函数中是把地址里面的值取出来再写地址进去, 所以也可以交换成功.

   ```c++
   // 3. use values
   void swapv(int a, int b)
   {
       int temp;
       temp = a;
       a = b;
       b = temp;
   }
   swapv(wallet1, wallet2);
   ```

   函数传进去的是wallet1和wallet2的值, 函数中的a和b只是复制了wallet1和wallet2的值, 对wallet1 和wallet2没有直接影响, 所以不会改变wallet1和wallet2的值.

7. 还有一个问题, 就是函数里面使用引用会改变传进去的参数的值:

   ```c++
   double cube(double &ra)
   {
       ra *= ra *ra;
       return ra;
   }
   ```

   这样出来的ra值会被改变. 如果你不想这样做, 你可以考虑这样:

   ```c++
   double refcube(const double &ra);
   ```

   这样让编译器发现代码改变了ra的值时报错.

   * 作为一个传递引用的函数, 引用就是变量的别名, 所以传进去的实参也应该时一个变量, 所以不能传表达式进去.

