# KMP算法

### 一些约定

* 主串/模式串: 一大串主串里找模式串
* 匹配/失配: 配上了/不匹配
* 指针: 指向这个串这个字符的一个抽象指针
* 子串: 一个串的一部分
* 前缀: 从第一个开始, 不包含整个串的子串
* 后缀: 从最后一个往前, 不包含整个串的子串

### 通行思路

1. 原本的暴力算法是, 一旦失配, 就[主串指针指向下一个]与[模式串指向第一个]从头再来. 
2. KMP的想法是, 不要从[主串指针的下一个]回退
3. 通过记录一些信息, 来减少回退的次数, 从而减少匹配的次数

### next的求解

* next用来给模式串的指针指示位置, 不要理解为索引(index), 而是理解为状态(States). 

* 我们可以认为, 一个个查看模式串是否匹配的过程是状态转移的过程, 模式串指针指向第一个的时候为初始状态, 指向最后一个的时候为最终状态, 当达到最终状态的时候, 匹配完成, 结果就出来了.

  例如`ABABC`作为模式串, 那么分别对应0-1-2-3-4-5共六种不同的状态. 当遇到状态4, 即在BC中间是时, 如果再遇到一个A, 状态就转移到了状态3, 如果再遇到一个C, 就转移到了状态5. 

* 处于不同状态时, 模式串的行为也不同, next数组的含义就是一个固定字符串的最长前缀和最长后缀相同的长度

```cpp
void cal_next(char *str, int *next, int len)
{
    next[0] = -1;//next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀
    int k = -1;//k初始化为-1
    for (int q = 1; q <= len-1; q++)
    {
        while (k > -1 && str[k + 1] != str[q])//如果下一个不同，那么k就变成next[k]，注意next[k]是小于k的，无论k取任何值。
        {
            k = next[k];//往前回溯
        }
        if (str[k + 1] == str[q])//如果相同，k++
        {
            k = k + 1;
        }
        next[q] = k;//这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]
    }
}
```

这时候KMP的算法就很简单了, 失配的时候, i不动, j的话取next数组中对应的数就好了